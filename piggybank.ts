/**
 * TripCostEstimation Concept - AI Augmented Version
 * 
 * Generates realistic cost estimates for travel plans using AI for data retrieval and calculation
 */

import { GeminiLLM } from './gemini-llm';

// Cost validation constants
const MAXCOST = 1e6;  // $1,000,000 - maximum reasonable cost for any travel component
const MINCOST = 0;    // $0 - minimum cost (free)

// User is just an identifier following modularity principles
export type User = number;

// Location represents a city
export interface Location {
    city: string;
}

// Travel plan with dates and necessities
export interface TravelPlan {
    id: string;
    user: User;
    fromCity: Location;
    toCity: Location;
    fromDate: Date;
    toDate: Date;
    necessity: Necessity;
}

// Necessity preferences for accommodation and dining
export interface Necessity {
    accommodation: boolean; // true for saving for rooms, false for not
    diningFlag: boolean;    // true for saving for eating out, false for not
}

// Cost estimate generated by AI
export interface CostEstimate {
    travelPlanID: string;
    flight: number;         // estimated total round-trip flight cost in USD
    roomsPerNight: number;  // estimated cost per night in USD
    foodDaily: number;      // estimated cost per day in USD
    lastUpdated: Date;      // tracking when the estimate was generated
}

export class TripCostEstimation {
    private travelPlans: TravelPlan[] = [];
    private costEstimates: CostEstimate[] = [];
    private nextPlanId = 1;

    /**
     * Create a new travel plan for a user
     * @requires fromCity.city !== toCity.city (different cities required)
     *         toDate >= fromDate (return date must be on or after departure date)
     *         fromDate > new Date() (departure date must be in the future)
     *         toDate > new Date() (return date must be in the future)
     * @returns TravelPlan with unique ID, user, cities, dates, and default necessity (accommodation: true, diningFlag: true)
     */
    createTravelPlan(user: User, fromCity: Location, toCity: Location, fromDate: Date, toDate: Date): TravelPlan {
        // Validate requirements
        if (toDate < fromDate) {
            throw new Error('toDate must be on or after fromDate');
        }
        if (fromDate <= new Date() || toDate <= new Date()) {
            throw new Error('both dates must be in the future');
        }

        const travelPlan: TravelPlan = {
            id: `plan_${this.nextPlanId++}`,
            user,
            fromCity,
            toCity,
            fromDate,
            toDate,
            necessity: { accommodation: true, diningFlag: true } // default necessity
        };

        this.travelPlans.push(travelPlan);
        return travelPlan;
    }

    /**
     * Delete a travel plan and its associated cost estimates
     * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)
     *         travelPlan.user === user (travel plan must belong to the specified user)
     * @returns void (no return value)
     *         travelPlan and all associated cost estimates are removed from system
     */
    deleteTravelPlan(user: User, travelPlan: TravelPlan): void {
        // Validate requirements
        if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {
            throw new Error('travelPlan must exist and belong to user');
        }

        // Remove associated cost estimates
        this.costEstimates = this.costEstimates.filter(estimate => estimate.travelPlanID !== travelPlan.id);
        
        // Remove the travel plan
        this.travelPlans = this.travelPlans.filter(plan => plan.id !== travelPlan.id);
    }

    /**
     * Update necessity preferences for a travel plan
     * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)
     *         travelPlan.user === user (travel plan must belong to the specified user)
     * @returns object containing updated travelPlan and necessity with new accommodation and diningFlag values
     *         travelPlan.necessity.accommodation === accommodation
     *         travelPlan.necessity.diningFlag === diningFlag
     */
    updateNecessity(user: User, travelPlan: TravelPlan, accommodation: boolean, diningFlag: boolean): { travelPlan: TravelPlan; necessity: Necessity } {
        // Validate requirements
        if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {
            throw new Error('travelPlan must exist and belong to user');
        }

        const necessity: Necessity = { accommodation, diningFlag };
        travelPlan.necessity = necessity;

        return { travelPlan, necessity };
    }

    /**
     * Reset necessity to default values
     * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)
     *         travelPlan.user === user (travel plan must belong to the specified user)
     * @returns void (no return value)
     *         travelPlan.necessity.accommodation === true
     *         travelPlan.necessity.diningFlag === true
     */
    resetNecessity(user: User, travelPlan: TravelPlan): void {
        // Validate requirements
        if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {
            throw new Error('travelPlan must exist and belong to user');
        }

        travelPlan.necessity = { accommodation: true, diningFlag: true };
    }

    /**
     * Generate AI cost estimate using Gemini LLM
     * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)
     *         travelPlan.user === user (travel plan must belong to the specified user)
     *         llm is a valid GeminiLLM instance
     * @returns Promise<CostEstimate> with flight, roomsPerNight, foodDaily costs and lastUpdated timestamp
     *         new CostEstimate is stored in system with travelPlan.id as travelPlanID
     */
    async generateAICostEstimate(user: User, travelPlan: TravelPlan, llm: GeminiLLM): Promise<CostEstimate> {
        // Validate requirements
        if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {
            throw new Error('travelPlan must exist and belong to user');
        }

        try {
            const prompt = this.createCostEstimationPrompt(travelPlan);
            const response = await llm.executeLLM(prompt);
            
            const costEstimate = this.parseAndValidateCostEstimate(response, travelPlan.id);
            
            // Store the cost estimate
            this.costEstimates.push(costEstimate);
            
            return costEstimate;
            
        } catch (error) {
            console.error('Error generating AI cost estimate:', (error as Error).message);
            throw error;
        }
    }

    /**
     * Calculate total cost for a travel plan
     * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)
     *         travelPlan.user === user (travel plan must belong to the specified user)
     *         cost estimate exists for travelPlan (CostEstimate with matching travelPlanID)
     * @returns number representing total cost (flight + accommodation + food) in USD
     */
    estimateCost(user: User, travelPlan: TravelPlan): number {
        const breakdown = this.getCostBreakdown(user, travelPlan);
        return breakdown.total;
    }

    /**
     * Get detailed cost breakdown for a travel plan
     * @requires travelPlan exists in system (travelPlan.id found in travelPlans array)
     *         travelPlan.user === user (travel plan must belong to the specified user)
     *         cost estimate exists for travelPlan (CostEstimate with matching travelPlanID)
     * @returns object containing flight cost, total accommodation cost, total food cost, total cost, and duration in days
     */
    getCostBreakdown(user: User, travelPlan: TravelPlan): {
        flight: number;
        accommodation: number;
        food: number;
        total: number;
        durationDays: number;
    } {
        // Validate requirements
        if (!this.travelPlanExists(travelPlan) || travelPlan.user !== user) {
            throw new Error('travelPlan must exist and belong to user');
        }

        const costEstimate = this.getCostEstimate(travelPlan.id);
        if (!costEstimate) {
            throw new Error('no cost estimate exists for this travel plan');
        }

        // Calculate duration in days
        const durationMs = travelPlan.toDate.getTime() - travelPlan.fromDate.getTime();
        const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));
        
        // Calculate individual costs
        const flight = costEstimate.flight;
        const accommodation = costEstimate.roomsPerNight * durationDays;
        const food = costEstimate.foodDaily * durationDays;
        const total = flight + accommodation + food;
        
        return {
            flight,
            accommodation,
            food,
            total,
            durationDays
        };
    }

    /**
     * Helper methods
     */
    /**
     * Check if a travel plan exists in the system
     * @requires travelPlan is a valid TravelPlan object
     * @returns boolean indicating whether travelPlan.id exists in travelPlans array
     */
    private travelPlanExists(travelPlan: TravelPlan): boolean {
        return this.travelPlans.some(plan => plan.id === travelPlan.id);
    }

    /**
     * Get cost estimate by travel plan ID
     * @requires travelPlanID is a non-empty string
     * @returns CostEstimate with matching travelPlanID, or undefined if not found
     */
    private getCostEstimate(travelPlanID: string): CostEstimate | undefined {
        return this.costEstimates.find(estimate => estimate.travelPlanID === travelPlanID);
    }

    /**
     * Create the prompt for Gemini AI cost estimation
     * @requires travelPlan is a valid TravelPlan object
     *         travelPlan.fromDate and travelPlan.toDate are valid Date objects
     * @returns string containing formatted prompt for Gemini LLM with trip details and instructions
     */
    private createCostEstimationPrompt(travelPlan: TravelPlan): string {
        const durationMs = travelPlan.toDate.getTime() - travelPlan.fromDate.getTime();
        const durationDays = Math.ceil(durationMs / (1000 * 60 * 60 * 24));
        
        const accommodationText = travelPlan.necessity.accommodation 
            ? "hotel/motel accommodation" 
            : "no accommodation needed (staying with friends/family or camping)";
            
        const diningText = travelPlan.necessity.diningFlag 
            ? "restaurant dining and meals" 
            : "no dining costs (self-catering or included meals)";

        return `
You are a helpful AI assistant that provides realistic cost estimates for travel plans.

TRIP DETAILS:
- From: ${travelPlan.fromCity.city}
- To: ${travelPlan.toCity.city}
- Duration: ${durationDays} days
- Departure: ${travelPlan.fromDate.toDateString()}
- Return: ${travelPlan.toDate.toDateString()}

NECESSITY PREFERENCES:
- Accommodation: ${accommodationText}
- Dining: ${diningText}

IMPORTANT INSTRUCTIONS FOR ACCURATE PRICING:
- For MEDIAN flight costs: Use Google Flights to search for round-trip flights between these cities for the specified dates to get current, accurate pricing
- For MEDIAN accommodation costs: Research current hotel/motel prices in the destination city for the specified dates
- For MEDIAN food costs: Research typical daily dining costs in the destination city

Please provide realistic cost estimates in USD for:
1. Round-trip flight MEDIAN cost between these cities (use Google Flights for accuracy)
2. MEDIAN Cost per night for accommodation (if accommodation is needed)
3. MEDIAN Daily food/dining costs (if dining is needed)

If accommodation is not needed, set rooms per night to 0.
If dining is not needed, set daily food cost to 0.

Return your response as a JSON object with this exact structure:
{
  "flight": estimated_flight_cost_number,
  "roomsPerNight": estimated_room_cost_per_night_number,
  "foodDaily": estimated_daily_food_cost_number
}

Return ONLY the JSON object, no additional text.`;
    }

    /**
     * Parse and validate the LLM response
     * @requires responseText is a non-empty string containing valid JSON
     *         travelPlanID is a non-empty string
     *         JSON contains numeric flight, roomsPerNight, and foodDaily fields
     *         all cost values are within range [MINCOST, MAXCOST]
     * @returns CostEstimate object with parsed values and current timestamp
     */
    private parseAndValidateCostEstimate(responseText: string, travelPlanID: string): CostEstimate {
        try {
            // VALIDATOR 1: Check for missing or malformed JSON
            this.validateJsonStructure(responseText);
            
            // Extract JSON from response
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('LLM_VALIDATION_ERROR: No JSON object found in response. Expected format: {"flight": number, "roomsPerNight": number, "foodDaily": number}');
            }

            let response: any;
            try {
                response = JSON.parse(jsonMatch[0]);
            } catch (parseError) {
                throw new Error('LLM_VALIDATION_ERROR: Invalid JSON format in response. Please ensure the LLM returns valid JSON.');
            }

            // VALIDATOR 2: Check for missing required fields
            this.validateRequiredFields(response);
            
            // VALIDATOR 3: Check for unrealistic cost ranges and logical inconsistencies
            this.validateCostRangesAndLogic(response);

            const costEstimate: CostEstimate = {
                travelPlanID,
                flight: response.flight,
                roomsPerNight: response.roomsPerNight,
                foodDaily: response.foodDaily,
                lastUpdated: new Date()
            };

            return costEstimate;
            
        } catch (error) {
            console.error('❌ LLM Response Validation Error:', (error as Error).message);
            console.log('📝 Raw LLM Response:', responseText);
            throw error;
        }
    }

    /**
     * VALIDATOR 1: Validate JSON structure and format
     * @requires responseText is a non-empty string
     */
    private validateJsonStructure(responseText: string): void {
        if (!responseText || responseText.trim().length === 0) {
            throw new Error('LLM_VALIDATION_ERROR: Empty response received from LLM');
        }

        // Check for common LLM response issues
        if (responseText.includes('```json') && !responseText.includes('```')) {
            throw new Error('LLM_VALIDATION_ERROR: Incomplete JSON code block detected. LLM may have been interrupted.');
        }

        if (responseText.includes('I cannot') || responseText.includes('I am unable')) {
            throw new Error('LLM_VALIDATION_ERROR: LLM declined to provide estimate. Response contains refusal language.');
        }

        // Check for non-JSON explanatory text that might indicate confusion
        const lines = responseText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        const jsonLines = lines.filter(line => line.startsWith('{') || line.includes('"flight"') || line.includes('"roomsPerNight"') || line.includes('"foodDaily"'));
        
        if (jsonLines.length === 0 && lines.length > 3) {
            throw new Error('LLM_VALIDATION_ERROR: LLM provided explanatory text but no JSON. Expected pure JSON response.');
        }
    }

    /**
     * VALIDATOR 2: Validate required fields are present and correct type
     * @requires response is a parsed JSON object
     */
    private validateRequiredFields(response: any): void {
        const requiredFields = ['flight', 'roomsPerNight', 'foodDaily'];
        const missingFields = requiredFields.filter(field => !(field in response));
        
        if (missingFields.length > 0) {
            throw new Error(`LLM_VALIDATION_ERROR: Missing required fields: ${missingFields.join(', ')}. Expected: ${requiredFields.join(', ')}`);
        }

        // Check field types
        const typeErrors: string[] = [];
        if (typeof response.flight !== 'number') {
            typeErrors.push(`flight (expected number, got ${typeof response.flight})`);
        }
        if (typeof response.roomsPerNight !== 'number') {
            typeErrors.push(`roomsPerNight (expected number, got ${typeof response.roomsPerNight})`);
        }
        if (typeof response.foodDaily !== 'number') {
            typeErrors.push(`foodDaily (expected number, got ${typeof response.foodDaily})`);
        }

        if (typeErrors.length > 0) {
            throw new Error(`LLM_VALIDATION_ERROR: Incorrect field types: ${typeErrors.join(', ')}`);
        }

        // Check for NaN or Infinity values
        const invalidValues: string[] = [];
        if (isNaN(response.flight) || !isFinite(response.flight)) {
            invalidValues.push('flight');
        }
        if (isNaN(response.roomsPerNight) || !isFinite(response.roomsPerNight)) {
            invalidValues.push('roomsPerNight');
        }
        if (isNaN(response.foodDaily) || !isFinite(response.foodDaily)) {
            invalidValues.push('foodDaily');
        }

        if (invalidValues.length > 0) {
            throw new Error(`LLM_VALIDATION_ERROR: Invalid numeric values (NaN/Infinity): ${invalidValues.join(', ')}`);
        }
    }

    /**
     * VALIDATOR 3: Validate cost ranges and logical consistency
     * @requires response has numeric flight, roomsPerNight, and foodDaily fields
     */
    private validateCostRangesAndLogic(response: any): void {
        const { flight, roomsPerNight, foodDaily } = response;

        // Check for negative values (impossible costs)
        const negativeValues: string[] = [];
        if (flight < 0) negativeValues.push(`flight (${flight})`);
        if (roomsPerNight < 0) negativeValues.push(`roomsPerNight (${roomsPerNight})`);
        if (foodDaily < 0) negativeValues.push(`foodDaily (${foodDaily})`);

        if (negativeValues.length > 0) {
            throw new Error(`LLM_VALIDATION_ERROR: Negative costs are impossible: ${negativeValues.join(', ')}`);
        }

        // Check for unreasonably high values (likely hallucination)
        const excessiveValues: string[] = [];
        if (flight > MAXCOST) excessiveValues.push(`flight (${flight} - exceeds $${MAXCOST.toLocaleString()} limit)`);
        if (roomsPerNight > MAXCOST) excessiveValues.push(`roomsPerNight (${roomsPerNight} - exceeds $${MAXCOST.toLocaleString()}/night limit)`);
        if (foodDaily > MAXCOST) excessiveValues.push(`foodDaily (${foodDaily} - exceeds $${MAXCOST.toLocaleString()}/day limit)`);

        if (excessiveValues.length > 0) {
            throw new Error(`LLM_VALIDATION_ERROR: Unrealistic excessive costs detected: ${excessiveValues.join(', ')}`);
        }

        // Check for suspiciously low values that might indicate confusion
        const suspiciouslyLowValues: string[] = [];
        if (flight > 0 && flight < 10) suspiciouslyLowValues.push(`flight (${flight} - suspiciously low for any flight)`);
        if (roomsPerNight > 0 && roomsPerNight < 1) suspiciouslyLowValues.push(`roomsPerNight (${roomsPerNight} - suspiciously low for accommodation)`);
        if (foodDaily > 0 && foodDaily < 1) suspiciouslyLowValues.push(`foodDaily (${foodDaily} - suspiciously low for daily food costs)`);

        if (suspiciouslyLowValues.length > 0) {
            console.warn(`⚠️  WARNING: Suspiciously low values detected: ${suspiciouslyLowValues.join(', ')}. Proceeding with caution.`);
        }

        // Check for logical inconsistencies
        if (roomsPerNight > flight && flight > 100) {
            throw new Error(`LLM_VALIDATION_ERROR: Logical inconsistency - room cost (${roomsPerNight}) exceeds flight cost (${flight}). This suggests LLM confusion.`);
        }

        // Check for decimal precision issues (likely copy-paste errors)
        const decimalIssues: string[] = [];
        if (flight.toString().split('.')[1]?.length > 2) decimalIssues.push(`flight (${flight} - excessive decimal places)`);
        if (roomsPerNight.toString().split('.')[1]?.length > 2) decimalIssues.push(`roomsPerNight (${roomsPerNight} - excessive decimal places)`);
        if (foodDaily.toString().split('.')[1]?.length > 2) decimalIssues.push(`foodDaily (${foodDaily} - excessive decimal places)`);

        if (decimalIssues.length > 0) {
            console.warn(`⚠️  WARNING: Excessive decimal precision detected: ${decimalIssues.join(', ')}. This may indicate LLM confusion.`);
        }
    }

    /**
     * Get travel plan by ID (for testing purposes)
     * @requires travelPlan is a valid TravelPlan object
     * @returns TravelPlan with matching ID, or undefined if not found
     */
    getTravelPlan(travelPlan: TravelPlan): TravelPlan | undefined {
        return this.travelPlans.find(plan => plan.id === travelPlan.id);
    }

    /**
     * Get cost estimate by travel plan ID (for testing purposes)
     * @requires travelPlan is a valid TravelPlan object
     * @returns CostEstimate with matching travelPlanID, or undefined if not found
     */
    getCostEstimateByPlan(travelPlan: TravelPlan): CostEstimate | undefined {
        return this.getCostEstimate(travelPlan.id);
    }
}